import{j as i}from"./jsx-runtime-C-_spy54.js";import{r as o}from"./index-aRQRyZp7.js";import{F as U,u as C,b as Y,o as B,f as H,s as J,c as K,d as L,e as X,g as $,h as z,i as Q,j as Z,k as ee,a as te,l as ne,m as oe}from"./floating-ui.react-DdrfVbJq.js";import{c as P}from"./index-DUolvyrz.js";const R=o.createContext(null);function _(){const e=o.useContext(R);if(e==null)throw new Error("Tooltip components must be wrapped in <Tooltip />");return e}const ie="_tooltip_6ode6_8",ae="_invisible_6ode6_21",re="_caption_6ode6_28",le="_arrow_6ode6_33",g={tooltip:ie,invisible:ae,caption:re,arrow:le},q={open:300,close:0},x=({children:e})=>i.jsx(U,{delay:q,timeoutMs:300,children:e});x.displayName="TooltipProvider";try{x.displayName="TooltipProvider",x.__docgenInfo={description:`Enables tooltips to share a global "warm-up" period for their hover delay.
You must wrap your application in this component for tooltips to function.`,displayName:"TooltipProvider",props:{}}}catch{}function se({open:e,disabled:a=!1,onOpenChange:r,placement:t="bottom",isTriggerInteractive:l,caption:n,"aria-atomic":h,"aria-live":u,...v}){const d=C(),c=C(),w=o.useRef(null),[V,N]=o.useState(!1),y=a?!1:e??V,p=(m,O,G)=>{r?.(m,O,G),e===void 0&&N(m)},T=Y({placement:t,open:y,onOpenChange:p,whileElementsMounted:ee,middleware:[B(6),H({crossAxis:t.includes("-"),fallbackAxisSideDirection:"start",padding:5}),J({padding:5}),K({element:w})]}),f=T.context,{delay:A,initialDelay:F}=L(f);if(F!==q)throw new Error("Tooltips must be wrapped in a global <TooltipProvider>");const W=X(f,{move:!1,enabled:e===void 0,delay:l?A:{},mouseOnly:!0}),M=$(f,{enabled:e===void 0}),s=o.useRef(void 0);o.useEffect(()=>()=>window.clearTimeout(s.current),[]);const S=o.useMemo(()=>{const m=()=>{s.current===void 0?s.current=window.setTimeout(()=>{p(!1),s.current=void 0},1500):window.clearTimeout(s.current)};return{reference:{onTouchStart:()=>{s.current!==void 0&&window.clearTimeout(s.current),s.current=window.setTimeout(()=>{p(!0),s.current=void 0},500)},onTouchEnd:m,onTouchCancel:m}}},[]),k=z(f),b="label"in v?"label":"description",I=Q(f,{enabled:b==="description",role:"tooltip"}),D=o.useMemo(()=>b==="label"?{reference:{"aria-labelledby":d,"aria-describedby":n?c:void 0}}:{},[b,d,c]),j=Z([W,M,S,k,I,D]);return o.useMemo(()=>({labelId:d,captionId:n?c:void 0,caption:n,purpose:b,open:y,setOpen:p,tooltipProps:{"aria-atomic":h,"aria-live":u},...j,...T,arrowRef:w}),[d,c,n,I,y,p,j,T,w])}const de=e=>"label"in e&&!!e.label;function E({children:e,isTriggerInteractive:a=!0,nonInteractiveTriggerTabIndex:r=0,...t}){const l=se({isTriggerInteractive:a,...t});return i.jsxs(R.Provider,{value:l,children:[i.jsx(pe,{isTriggerInteractive:a,nonInteractiveTriggerTabIndex:r,children:e}),i.jsxs(ue,{children:[i.jsx("span",{id:l.labelId,children:de(t)?t.label:t.description}),i.jsx(ce,{})]})]})}function ce(){const{caption:e,captionId:a}=_();if(!e)return null;const t=typeof e=="string"?"span":"div";return i.jsx(t,{id:a,className:P(g.caption,"cpd-theme-dark"),children:e})}function ue({children:e}){const{context:a,open:r,arrowRef:t,purpose:l,...n}=_();return!r&&l!=="label"?null:i.jsx(ne,{children:i.jsxs("div",{ref:n.refs.setFloating,style:n.floatingStyles,...n.tooltipProps,...n.getFloatingProps(),className:P(g.tooltip,{[g.invisible]:l==="label"&&!r}),children:[i.jsx(oe,{ref:t,context:a,width:10,height:6,className:g.arrow}),e]})})}const pe=({children:e,isTriggerInteractive:a,nonInteractiveTriggerTabIndex:r})=>{const t=_(),l=e?.ref,n=te([t.refs.setReference,l]),h=o.useMemo(()=>{if(o.isValidElement(e))if(a){const u=t.getReferenceProps({ref:n});return o.cloneElement(e,u)}else{const u=t.getReferenceProps({ref:n,tabIndex:r}),{"aria-labelledby":v,"aria-describedby":d,...c}=u;return i.jsx("span",{tabIndex:r,...c,children:o.cloneElement(e,{"aria-labelledby":v,"aria-describedby":d})})}},[t,n,e]);if(!h)throw new Error("Tooltip anchor must be a single valid React element");return h};try{E.displayName="Tooltip",E.__docgenInfo={description:"A tooltip component",displayName:"Tooltip",props:{disabled:{defaultValue:null,description:"Whether the tooltip should be forced to be in a closed state.",name:"disabled",required:!1,type:{name:"boolean"}},caption:{defaultValue:null,description:`The caption of the tooltip.
JSX.Element can be used to provide accessibility content like kbd element.
Keep in mind, the caption should not be used for interactive content.`,name:"caption",required:!1,type:{name:"string | Element"}},"aria-atomic":{defaultValue:null,description:`Additional aria-* attributes to pass through to the floating tooltip for
edge cases which require more user awareness like errors & alerts.`,name:"aria-atomic",required:!1,type:{name:"Booleanish"}},"aria-live":{defaultValue:null,description:"",name:"aria-live",required:!1,type:{name:"enum",value:[{value:'"off"'},{value:'"assertive"'},{value:'"polite"'}]}},open:{defaultValue:{value:"undefined"},description:`The controlled open state of the tooltip.
If provided, the tooltip will be in controlled mode.
When true, the tooltip is always open. When false, the tooltip is always hidden.
When undefined, the tooltip will manage its own open state.
You will mostly want to omit this property. Will be used the vast majority
of the time during development.`,name:"open",required:!1,type:{name:"boolean"}},onOpenChange:{defaultValue:null,description:"The event handler for the open change.",name:"onOpenChange",required:!1,type:{name:"((open: boolean, event?: Event, reason?: OpenChangeReason) => void) | undefined"}},placement:{defaultValue:{value:'"bottom"'},description:"The placement of the tooltip.",name:"placement",required:!1,type:{name:"enum",value:[{value:'"left"'},{value:'"right"'},{value:'"bottom"'},{value:'"top"'},{value:'"left-end"'},{value:'"left-start"'},{value:'"right-end"'},{value:'"right-start"'},{value:'"bottom-end"'},{value:'"bottom-start"'},{value:'"top-end"'},{value:'"top-start"'}]}},label:{defaultValue:null,description:"A label for the target element.",name:"label",required:!0,type:{name:"string"}},isTriggerInteractive:{defaultValue:{value:"true"},description:`Whether the trigger element is interactive.
When trigger is interactive:
     - tooltip will be shown after a 300ms delay.
When trigger is not interactive:
     - tooltip will be shown instantly when pointer enters trigger.
     - trigger will be wrapped in a span with a tab index from prop nonInteractiveTriggerTabIndex`,name:"isTriggerInteractive",required:!1,type:{name:"boolean"}},nonInteractiveTriggerTabIndex:{defaultValue:{value:"0"},description:"The tab index for the non interactive trigger.",name:"nonInteractiveTriggerTabIndex",required:!1,type:{name:"number"}},description:{defaultValue:null,description:"A description for the target element.",name:"description",required:!0,type:{name:"string"}}}}}catch{}export{x as T,E as a};
